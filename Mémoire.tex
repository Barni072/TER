\documentclass[french]{article}
\usepackage[french]{babel}
\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{listings}
\usepackage[]{algorithm2e}
\usepackage[margin=3.2cm,footskip=2cm]{geometry}
\usepackage{enumitem}
\usepackage{amsfonts}
\usepackage{float}
\usepackage{stmaryrd}
\usepackage{ifpdf}
\ifpdf
\usepackage[colorlinks,pdftex]{hyperref}
\else
\usepackage[ps2pdf,breaklinks=true,colorlinks=true,linkcolor=red,citecolor=green]{hyperref}
\fi
\setcounter{MaxMatrixCols}{42}

\begin{document}
\begin{titlepage}
	\begin{figure}[htbp]
		\hbox{
			\hspace*{12.5cm}
		}
	\end{figure}
	\vspace {-1.8cm}
	\begin{center}
		{\bf {\large Université Grenoble Alpes}}\\
		{\bf {\large Institut Fourier}}\\
		\vspace{4cm}
		\huge{\textbf{Travail d'Étude et de Recherche}}\\
		\vspace{0.7cm}
		\noindent\rule{\textwidth}{1mm}
		\Large{\textbf{Implémentation en C/C++ de la résolution exacte de systèmes linéaires à coefficients entiers}}
		\noindent\rule{\textwidth}{1mm}
		\vspace{0.7cm}
		%% Laisser une ligne vide ici sinon ça casse (?!)
		
		{\large
		\textbf{Réalisé par}\\
		Barnabé Chabaux\\
		\vspace{0.5cm}
		\textbf{Encadré par}\\
		Bernard Parisse\\}
		\vspace{9cm}
		2024/2025
	\end{center}
\end{titlepage}
\tableofcontents
\newpage
\section{Introduction et objectifs} \label{sec:intro}
L'objectif de ce TER est d'implémenter en langage C, par diverses méthodes, la résolution exacte de systèmes linéaires à coefficients entiers. Le code écrit pour ce travail peut être consulté sur \href{https://github.com/Barni072/TER}{mon Github}.
\par On va d'abord naïvement programmer le pivot de Gauss (section \ref{sec:gauss}), puis l'améliorer un peu de sorte à ce qu'il ne fasse intervenir que des entiers (algorithme de Bareiss, section \ref{sec:bareiss}), et implémenter une méthode de résolution modulaire, où l'on résout le système (par le pivot de Gauss) dans $\mathbb{Z}/p\mathbb{Z}$ pour différents nombres premiers $p$ (section \ref{sec:modulaire}).
\par
Le système linéaire que l'on cherche à résoudre est de cette forme :
\newline
$$\left \{
\begin{array}{ccccccccccc}
	a_{1,1} x_1 &+ &\cdots &+ &a_{1,j} x_j &+ &\cdots &+ &a_{1,n} x_n &= & b_1\\
	\vdots & & & & \vdots & & & & \vdots & & \vdots\\
	a_{i,1} x_1 &+ &\cdots &+ &a_{i,j} x_j &+ &\cdots &+ &a_{i,n} x_n &= & b_i\\
	\vdots & & & & \vdots & & & & \vdots & & \vdots\\
	a_{n,1} x_1 &+ &\cdots &+ &a_{n,j} x_j &+ &\cdots &+ &a_{n,n} x_n &= & b_n
\end{array}
\right.
$$
où $a_{i,j}$ et les $b_i$ sont des entiers donnés, et les inconnues sont les $x_j$.
\newline
On peut le représenter sous forme matricielle :
\begin{equation*}
	\begin{pmatrix}
		a_{1,1} & a_{1,2} & \cdots & a_{1,j} & \cdots & a_{1,n}\\
		a_{2,1} & a_{2,2} & \cdots & a_{2,j} & \cdots & a_{2,n}\\
		\vdots  & \vdots  & & \vdots & & \vdots\\
		a_{i,1} & a_{i,2} & \cdots & a_{i,j} & \cdots & a_{i,n}\\
		\vdots  & \vdots  &  & \vdots & &\vdots\\
		a_{n,1} & a_{n,2} & \cdots & a_{n,j} & \cdots & a_{n,n}
	\end{pmatrix}
	\begin{pmatrix}
		x_1\\
		x_2\\
		\vdots\\
		x_j\\
		\vdots\\
		x_n
	\end{pmatrix}
	=
	\begin{pmatrix}
		b_1\\
		b_2\\
		\vdots\\
		b_i\\
		\vdots\\
		b_n
	\end{pmatrix}
\end{equation*}
Mais pour gagner en place (et, avec un peu de chance, en lisibilité), on le représentera surtout sous la forme suivante, avec le second membre "dans" la matrice :
\begin{equation*}
	\begin{pmatrix}
		a_{1,1} & a_{1,2} & \cdots & a_{1,j} & \cdots & a_{1,n}&&b_1\\
		a_{2,1} & a_{2,2} & \cdots & a_{2,j} & \cdots & a_{2,n}&&b_2\\
		\vdots  & \vdots  & & \vdots & & \vdots&&\vdots\\
		a_{i,1} & a_{i,2} & \cdots & a_{i,j} & \cdots & a_{i,n}&&b_i\\
		\vdots  & \vdots  &  & \vdots & &\vdots&&\vdots\\
		a_{n,1} & a_{n,2} & \cdots & a_{n,j} & \cdots & a_{n,n}&&b_n
	\end{pmatrix}
\end{equation*}
Cette représentation a l'avantage de correspondre à la façon dont sont stockés les coefficients du système dans mon implémentation, qu'on exposera dans la section \ref{subsec:systemes}.
\section{Pivot de Gauss} \label{sec:gauss}
La première méthode qui vient à l'esprit pour résoudre des systèmes linéaires est le pivot de Gauss, tel que vu en classe de L1. On peut utiliser cette méthode directement en voyant les coefficients du système comme des rationnels (cela a été implémenté dans {\tt gauss\_sys\_rat.c}), mais on s'en servira aussi plus tard (dans la section \ref{sec:modulaire}) dans des corps finis.
\subsection{Algorithme}
\subsubsection{Pseudo-code}
\begin{algorithm}[H]
	\caption{Pivot de Gauss}
	\DontPrintSemicolon
	\Entree{Un système de Cramer de taille $n$, à coefficients entiers}
	\Sortie{Le même système linéaire, échelonné}
	\Pour{k allant de 1 à n}{
		\tcp{On échange éventuellement des lignes, de sorte que $a_{k,k}$ soit non nul et puisse servir de pivot}
		\Si{$a_{k,k} = 0$}{
			\eSi{$\exists l > k$ tel que \ $a_{l,k} \neq 0$ }{
				Échanger la $k$-ième ligne avec la $l$-ième
			}{
				\tcp{Le système n'est pas de Cramer}
				Renvoyer une erreur
			}
		}
		\tcp{Si on souhaite calculer le déterminant du système, il faut garder en mémoire la parité du nombre de permutations effectuées}
		\Pour{i allant de k+1 à n}{
			\tcp{On traite les coefficients de la $i$-ème ligne}
			\Pour{j allant de k à n}{
				$a_{i,j} \gets a_{i,j}-\frac{a_{i,k} a_{k,j}}{a_{k,k}}$
				\tcp*{On remarque que $a_{i,k}$ vaut ainsi 0}
			}
			\tcp{On n'oublie pas la $i$-ème coordonnée du second membre}
			$b_i \gets b_i-\frac{a_{i,k} b_k}{a_{k,k}}$
		}
	}
\end{algorithm}
\leavevmode \newline
Après avoir échelonné le système, il reste à "remonter" pour en obtenir la solution :\\\\
\begin{algorithm}[H]
	\caption{Obtention d'une solution à partir d'un système échelonné}
	\DontPrintSemicolon
	\Entree{Un système de Cramer échelonné}
	\Sortie{La solution $x$ de ce système}
	\Pour{k allant de n à 1}{
		$x_k \gets b_k$\\
		\Pour{l allant de k+1 à n}{
			$x_k \gets x_k - a_{k,l} x_l$
		}
		$x_k \gets \frac{x_k}{a_{k,k}}$
	}
\end{algorithm}
\subsubsection{Avec un système}
Voyons ce que cet algorithme donne sur un système. On se place dans le cas où les $k$ premières lignes ont été échelonnées.
\begin{equation*}
	\begin{pmatrix}
		a_{1,1} & \cdots & a_{1,k-1} & a_{1,k} & a_{1,k+1} & \cdots & a_{1,n}&&b_1\\
		\vdots  & \ddots & \vdots & \vdots & \vdots & & \vdots&&\vdots\\
		0 & & a_{k-1,k-1} & a_{k-1,k} & a_{k-1,k+1} & \cdots & a_{k-1,n}&&b_{k-1}\\
		0 & \cdots & 0 & a_{k,k} & a_{k,k+1} & \cdots & a_{k,n}&&b_k\\
		0 & \cdots & 0 & a_{k+1,k} & a_{k+1,k+1} & \cdots & a_{k+1,n}&&b_{k+1}\\
		\vdots  & & \vdots & \vdots & \vdots & & \vdots&&\vdots\\
		0 & \cdots & 0 & a_{n,k} & a_{n,k+1} & \cdots & a_{n,n}&&b_n\\
	\end{pmatrix}
\end{equation*}
Après l'itération du $k$-ème pivot, le système ressemble à ceci :
\begin{equation*}
	\begin{pmatrix}
		a_{1,1} & \cdots & a_{1,k-1} & a_{1,k} & a_{1,k+1} & \cdots & a_{1,n}&&b_1\\
		\vdots  & \ddots & \vdots & \vdots & \vdots & & \vdots&&\vdots\\
		0 & & a_{k-1,k-1} & a_{k-1,k} & a_{k-1,k+1} & \cdots & a_{k-1,n}&&b_{k-1}\\
		0 & \cdots & 0 & a_{k,k} & a_{k,k+1} & \cdots & a_{k,n}&&b_k\\
		0 & \cdots & 0 & 0 & a_{k+1,k+1}-\frac{a_{k+1,k} a_{k,k+1}}{a_{k,k}} & \cdots & a_{k+1,n}-\frac{a_{k+1,k} a_{k,n}}{a_{k,k}}&&b_{k+1}-\frac{a_{k+1,k} b_k}{a_{k,k}}\\
		\vdots  & & \vdots & \vdots & \vdots & & \vdots&&\vdots\\
		0 & \cdots & 0 & 0 & a_{n,k+1}-\frac{a_{n,k} a_{k,k+1}}{a_{k,k}} & \cdots & a_{n,n}-\frac{a_{n,k} a_{k,n}}{a_{k,k}}&&b_n-\frac{a_{n,k} b_k}{a_{k,k}}\\
	\end{pmatrix}
\end{equation*}
La matrice est désormais échelonnée jusqu'à la $(k+1)$-ème ligne.
\subsection{Exemple}
Considérons un petit système de taille 3, avec des coefficients entiers vus comme des rationnels :
\begin{equation*}
	\begin{cases}
		17 x_1 + 2 x_2 - 3 x_3 = 9\\
		4 x_1 + 7 x_2 - 8 x_3 = -5\\
		x_1 + 5 x_3 = 4
	\end{cases}
\end{equation*}
Ou, sous forme "matricielle avec second membre" :
\begin{equation*}
	\begin{pmatrix}
		17 & 2 & -3 & & 9\\
		4 & 7 & -8 & & -5\\
		1 & 0 & 5 & & 4
	\end{pmatrix}
\end{equation*}
Le premier pivot est $a_{1,1} = 17$
\begin{equation*}
	\begin{pmatrix}
		17 & 2 & -3 & & 9\\
		0 & \frac{111}{17} & \frac{124}{17} & & \frac{-121}{17}\\
		0 & \frac{-2}{17} & \frac{88}{17} & & \frac{59}{17}
	\end{pmatrix}
\end{equation*}
Le second pivot est $a_{2,2} = \frac{-124}{17}$
\begin{equation*}
	\begin{pmatrix}
		17 & 2 & -3 & & 9\\
		0 & \frac{111}{17} & \frac{124}{17} & & \frac{-121}{17}\\
		0 & 0 & \frac{560}{111} & & \frac{371}{111}
	\end{pmatrix}
\end{equation*}
Le système est échelonné. On en déduit sa solution :
\begin{equation*}
	\begin{cases}
		x_1 = \frac{11}{16}\\
		x_2 = \frac{-7}{20}\\
		x_3 = \frac{53}{80}
	\end{cases}
\end{equation*}
Notons que pour des système plus grands, la taille des coefficients a tendance à exploser. Par exemple, pour un système de taille 10, avec des coefficients (tirés uniformément) dans $\llbracket-256,255\rrbracket$, le coefficient $a_{10,10}$ en fin d'exécution est $\frac{-237000942794966946715916}{675552153160270013441}$.
\subsection{Complexité}
Cet algorithme effectue $O(n^3)$ opérations sur le corps dans lequel on l'utilise. C'est intéressant dans un corps fini où ce coût est constant, mais beaucoup moins si on l'utilise directement sur un système à coefficients entiers (donc dans le corps $\mathbb{Q}$), où il dépend de la taille des éléments (qui a tendance à vite croître).
\section{Algorithme de Bareiss} \label{sec:bareiss}
L'algorithme de Bareiss est une variante du pivot de Gauss, qui permet d'éviter de se retrouver avec des coefficients rationnels (non entiers). Son implémentation peut être consultée dans le fichier {\tt bareiss.c}.
\subsection{Algorithme}
\subsubsection{Pseudo-code}
\begin{algorithm}[H]
	\DontPrintSemicolon
	\caption{Algorithme de Bareiss}
	\Entree{Un système de Cramer de taille $n$, à coefficients entiers}
	\Sortie{Le même système linéaire, échelonné, et à coefficients entiers}
	$a_{0,0} \gets 1$
	\tcp*{On décrète que le "$0$-ème" pivot est 1, de sorte que diviser par $a_{0,0}$ ne change rien}
	\Pour{k allant de 1 à n}{
		\eSi{$\exists l \geq k$ tel que \ $a_{l,k} \neq 0$ }{
			Choisir $l \geq k$ tel que $\lvert a_{l,k} \rvert$ soit non nul et minimal
			\\
			Échanger la $k$-ième ligne avec la $l$-ième
			\\
			\tcp{Cela réduit un peu la complexité des calculs à effectuer}
		}{
			\tcp{Le système n'est pas de Cramer}
			Renvoyer une erreur
		}
		\Pour{i allant de k+1 à n}{
			\tcp{On traite les coefficients de la $i$-ème ligne}
			\Pour{j allant de k à n}{
				$a_{i,j} \gets \frac{a_{i,j} a_{k,k} - a_{i,k} a_{k,j}}{a_{k-1,k-1}}$
				\tcp*{On remarque que $a_{i,k}$ vaut ainsi 0}
			}
			\tcp{On n'oublie pas la $i$-ème coordonnée du second membre}
			$b_i \gets \frac{b_i a_{k,k} - a_{i,k} b_k}{a_{k-1,k-1}}$
		}
	}
\end{algorithm}
\leavevmode \newline
Une fois le système échelonné, il reste à obtenir la solution, en remontant avec l'algorithme 2, comme précédemment.
\subsubsection{Avec un système}
Comme pour le pivot de Gauss, voyons à quoi ressemble une itération de la boucle principale de l'algorithme de Bareiss. Ici, les $k$ premières lignes sont échelonnées.
\begin{equation*}
	\begin{pmatrix}
		a_{1,1} & \cdots & a_{1,k-1} & a_{1,k} & a_{1,k+1} & \cdots & a_{1,n}&&b_1\\
		\vdots  & \ddots & \vdots & \vdots & \vdots & & \vdots&&\vdots\\
		0 & & a_{k-1,k-1} & a_{k-1,k} & a_{k-1,k+1} & \cdots & a_{k-1,n}&&b_{k-1}\\
		0 & \cdots & 0 & a_{k,k} & a_{k,k+1} & \cdots & a_{k,n}&&b_k\\
		0 & \cdots & 0 & a_{k+1,k} & a_{k+1,k+1} & \cdots & a_{k+1,n}&&b_{k+1}\\
		\vdots  & & \vdots & \vdots & \vdots & & \vdots&&\vdots\\
		0 & \cdots & 0 & a_{n,k} & a_{n,k+1} & \cdots & a_{n,n}&&b_n\\
	\end{pmatrix}
\end{equation*}
Après l'itération du $k$-ème pivot, le système ressemble à ceci :
\begin{equation*}
	\begin{pmatrix}
		a_{1,1} & \cdots & a_{1,k-1} & a_{1,k} & a_{1,k+1} & \cdots & a_{1,n}&&b_1\\
		\vdots  & \ddots & \vdots & \vdots & \vdots & & \vdots&&\vdots\\
		0 & & a_{k-1,k-1} & a_{k-1,k} & a_{k-1,k+1} & \cdots & a_{k-1,n}&&b_{k-1}\\
		0 & \cdots & 0 & a_{k,k} & a_{k,k+1} & \cdots & a_{k,n}&&b_k\\
		0 & \cdots & 0 & 0 & \frac{a_{k+1,k+1} a_{k,k} - a_{k+1,k} a_{k,k+1}}{a_{k-1,k-1}} & \cdots & \frac{a_{k+1,n} a_{k,k} - a_{k+1,k} a_{k,n}}{a_{k-1,k-1}}&&\frac{b_{k+1} a_{k,k} - a_{k+1,k} b_k}{a_{k-1,k-1}}\\
		\vdots  & & \vdots & \vdots & \vdots & & \vdots&&\vdots\\
		0 & \cdots & 0 & 0 & \frac{a_{n,k+1} a_{k,k} - a_{n,k} a_{k,k+1}}{a_{k-1,k-1}} & \cdots & \frac{a_{n,n} a_{k,k} - a_{n,k} a_{k,n}}{a_{k-1,k-1}}&&\frac{b_{n} a_{k,k} - a_{n,k} b_k}{a_{k-1,k-1}}
	\end{pmatrix}
\end{equation*}
Les $k+1$ premières lignes de la matrice sont désormais échelonnées.
\subsection{Exemple}
Pour éviter de rajouter des étapes (et ainsi rester à peu près lisible), on ne cherchera pas à échanger les lignes pour minimiser la taille des pivots. Considérons le même petit système que précédemment.
\begin{equation*}
	\begin{pmatrix}
		17 & 2 & -3 & & 9\\
		4 & 7 & -8 & & -5\\
		1 & 0 & 5 & & 4
	\end{pmatrix}
\end{equation*}
Le premier pivot est $a_{1,1} = 17$
\begin{equation*}
	\begin{pmatrix}
		17 & 2 & -3 & & 9\\
		0 & 111 & -124 & & -121\\
		0 & -2 & 88 & & 59
	\end{pmatrix}
\end{equation*}
Le second pivot est $a_{2,2} = 111$
\begin{equation*}
	\begin{pmatrix}
		17 & 2 & -3  & & 9\\
		0 & 111 & -124 & & -121\\
		0 & 0 & 560 & & 371
	\end{pmatrix}
\end{equation*}
Le système est échelonné. On en déduit sa solution :
\begin{equation*}
	\begin{cases}
		x_1 = \frac{11}{16}\\
		x_2 = \frac{-7}{20}\\
		x_3 = \frac{53}{80}
	\end{cases}
\end{equation*}
On remarque que c'est bien la même solution que précédemment.
\subsection{Explications}
\subsubsection{Coefficients entiers}
[Idée générale : les coefficients du système sont des déterminants de matrices entières, et sont donc entiers]
\newline
Notons $L_i$ la $i$-ième ligne du système. Considérons l'opération suivante, que l'on effectue pour chaque pivot lors de l'algorithme :
$$L_i \gets \frac{a_{k,k} L_i - a_{i,k} L_k}{a_{k-1,k-1}}$$
Contrairement à la simple tranvection que l'on effectue lors du pivot de Gauss, cette opération modifie le déterminant du système, qui se voit multiplié par $\frac{a_{k,k}}{a_{k-1,k-1}}$.
Pour le $k$-ième pivot, on effectue cette opération pour chacune des $n-k$ lignes suivantes, ce qui multiplie le déterminant par $\frac{a_{k,k}^{n-k}}{a_{k-1,k-1}^{n-k}}$.
À la fin de l'algorithme (donc après avoir traité les pivots $1$ à $n-1$), on a donc multiplié le déterminant par :
$$a_{1,1}^{n-1} \times \frac{a_{2,2}^{n-2}}{a_{1,1}^{n-2}} \times \frac{a_{3,3}^{n-3}}{a_{2,2}^{n-3}} \times \hdots \times \frac{a_{n-2,n-2}^2}{a_{n-3,n-3}^2} \times \frac{a_{n-1,n-1}}{a_{n-2,n-2}} = a_{1,1} \times a_{2,2} \times \hdots \times a_{n-1,n-1}$$
[Comment conclut-on à partir de ça ?]
\newline
\subsubsection{Borne de Hadamard} \label{subsubsec:hada}
Soit $A \in M_n(\mathbb{R})$ (ou, en fait, $M_n(\mathbb{C})$). On note $C_1,\hdots,C_n$ ses vecteurs colonnes. On a :
$$ \lvert \mbox{det}(A) \rvert \le \lVert C_1 \rVert_2 \hdots \lVert C_n \rVert_2$$
Notons $n$ la taille du système (son nombre de lignes), et $a$ la taille des coefficients initiaux le nombre de bits nécessaires pour les écrire). Lors de l'exécution de l'algorithme, les coefficients du système étant des déterminants de sous-matrices, leur taille est donc au plus de l'ordre de $a n \mbox{ ln}(n)$.
\newline
[Preuve ??]
\newline
En effet : $\lVert C_i \rVert_2 = \sqrt{a_{1,i}^2 + \hdots + a_{n,i}^2}$ a une taille en $O(a \mbox{ ln}(n))$, et donc $\lVert C_1 \rVert_2 \hdots \lVert C_n \rVert_2$ a bien une taille en $O(a n \mbox{ ln}(n))$.
\subsubsection{Complexité de l'algorithme}
 Lors de l'exécution de l'algorithme, les coefficients sont des déterminants de sous-matrices, donc leur taille est en $O(an \mbox{ ln}(a n))$. Les multiplications $a_{i,j} a_{k,k}$ et $a_{i,k} a_{k,j}$ ont chacune un coût en $O(a^2 n^2 \mbox{ ln}(n)^2)$ avec la multiplication classique "naïve". Le calcul de chaque coefficient à chaque étape vaut donc lui aussi $O(a^2 n^2 \mbox{ ln}(n)^2)$. Ce calcul étant fait de l'ordre de $n^3$ fois, la complexité totale de l'algorithme de Bareiss est en $O(a^2 n^5 \mbox{ ln}(n)^2)$. Avec une meilleure multiplication (FFT), le calcul de chaque coefficient coûte seulement $O(a n \mbox{ ln}(n)^2)$, ce qui porte la complexité totale de l'algorithme à $O(a^2 n^4 \mbox{ ln}(n)^2)$.
\section{Méthode modulaire} \label{sec:modulaire}
L'idée de la méthode modulaire est de résoudre le système modulo divers nombres premiers, et d'utiliser ces solutions modulaires pour construire la solution du système de départ. Une telle méthode pose d'emblée différents problèmes :
\begin{itemize}
	\item Il est nécessaire de "combiner" des éléments de $\mathbb{Z}/n_1\mathbb{Z}$ et de $\mathbb{Z}/n_2\mathbb{Z}$ pour obtenir des éléments de $\mathbb{Z}/n_1n_2\mathbb{Z}$. Cela correspond précisément au théorème des restes chinois (\ref{subsec:chin}).
	\item Il faut obtenir une solution (du système initial) à la fin, et donc un moyen de construire celle-ci. Deux approches ont été essayées : la construction de rationnels à partir d'éléments de $\mathbb{Z}/a\mathbb{Z}$ (\ref{subsec:recrat}), et une méthode utilisant la règle de Cramer (\ref{subsec:cramer}).
	\item Enfin, il est nécessaire de savoir quand s'arrêter de faire des résolutions modulaires et renvoyer la solution. Là aussi, deux approches ont été essayées : construire un candidat solution à chaque itération et comparer avec celui de l'itération précédente, ou comparer le produit des nombres premiers utilisés avec la borne de Hadamard (voir \ref{subsubsec:hada}) du système.
\end{itemize}
\subsection{Restes Chinois} \label{subsec:chin}
On cherche à obtenir $x \in \mathbb{Z}/n\mathbb{Z}$ tel que :
\begin{equation*}
	\begin{cases}
		x \equiv x_1 \pmod n_1\\
		x \equiv x_2 \pmod n_2
	\end{cases}
\end{equation*}
[Méthode naïve]
\newline
[Méthode mieux (si elle marche (et est effctivement mieux))]
\subsection{Reconstruction rationnelle} \label{subsec:recrat}
À partir d'un $b \in \mathbb{Z}/a\mathbb{Z}$, on cherche à obtenir un rationnel $\frac{num}{den}$, avec $num \in \mathbb{Z}$ et $den \in \mathbb{N}^*$ premiers entre eux, tel que :
\begin{equation*}
	\begin{cases}
		num \  den^{-1} \equiv b \pmod a\\
		\lvert num \rvert < \frac{\sqrt{a}}{2}\\
		0 < den < \frac{\sqrt{a}}{2}\\
		den \wedge a = 1
	\end{cases}
\end{equation*}
Pour cela, on utilise une variante de l'algorithme d'Euclide étendu, où on s'arrête dès qu'on obtient un reste strictement inférieur à $\sqrt{a}$.\newline\newline
\begin{algorithm}[H]
	\DontPrintSemicolon
	\caption{Reconstruction rationnelle avec l'algorithme d'Euclide étendu}
	\Entree{$a \in \mathbb{N}^*, \ b \in \mathbb{Z}/a\mathbb{Z}$}
	\Sortie{$\frac{num}{den}$, vérifiant les conditions souhaitées}
	$r_0 \gets a$\\
	$r_1 \gets b$\\
	$v_0 \gets 0$\\
	$v_1 \gets 1$\\
	\tcp{$u_0$ et $u_1$ ne sont pas nécessaires ici}
	$k \gets 1$\\
	\Tq{$r_k \geq \sqrt{a}$}{
		$k\gets k+1$\\
		$q \gets$ quotient de la division euclidienne de $r_{k-2}$ par $r_{k-1}$\\
		$r_k \gets r_{k-2} - q r_{k-1}$
		\tcp*{Reste de la division euclidienne ci-dessus}
		$v_k \gets  v_{k-2} - q v_{k-1}$
	}
	\tcp{À ce stade, $den = \lvert v_k \rvert$ et $num = \pm v_k$ (selon le signe de $v_k$)}
	\tcp{On veut s'assurer que le signe soit "porté" par $num$ :}
	\eSi{$v_k < 0$}{
		\Retour{$\frac{-r_k}{-v_k}$}
	}{
		\Retour{$\frac{r_k}{v_k}$}
	}
\end{algorithm}
\leavevmode \newline
Typiquement, dans ce qui va suivre, on utilisera la reconstruction rationnelle pour calculer chacune des coordonnées de la solution, donc $n$ fois.
\newline
On verra dans la section \ref{subsec:modcompl} que la reconstruction rationnelle est trop coûteuse pour être utilisée à chaque itération. [Parler du coût ici ? Ou seulement dans la subsection complexité ?][+ Parler de la potentielle utilisation pour la méthode p-adique, qui n'a pas été implémentée]
\subsection{Règle de Cramer} \label{subsec:cramer}
[L'implémenter correctement avant de trop en parler ?]
\newline
Considérons un système linéaire de taille $n$ :
$$ A x = b$$
(On a donc $A \in M_n(\mathbb{Z})$ et $b \in \mathbb{Z}^n$ donnés, et l'inconnue est $x \in \mathbb{Q}^n$)
\newline
Notons $A_j$ la matrice $A$ dont la $j$-ième colonne a été remplacée par le second membre $b$ :
\begin{equation*}
	A_j = 
	\begin{pmatrix}
		a_{1,1} & a_{1,2} & \cdots & a_{1,j-1} & b_1 & a_{1,j+1} & \cdots & a_{1,n}\\
		a_{2,1} & a_{2,2} & \cdots & a_{2,j-1} & b_2 & a_{2,j+1} & \cdots & a_{2,n}\\
		\vdots  & \vdots  & & \vdots & \vdots & \vdots & & \vdots\\
		a_{i,1} & a_{i,2} & \cdots & a_{i,j-1} & b_i & a_{i,j+1} & \cdots & a_{i,n}\\
		\vdots  & \vdots  & & \vdots & \vdots & \vdots & & \vdots\\
		a_{n,1} & a_{n,2} & \cdots & a_{n,j-1} & b_n & a_{n,j+1} &\cdots & a_{n,n}
	\end{pmatrix}
	\in M_n(\mathbb{Z})
\end{equation*}
On a alors :
$$ \forall j \in \llbracket1,n\rrbracket, x_j = \frac{det(A_j)}{det(A)}$$
\newline
Pour obtenir le déterminant d'un système échelonné par le pivot de Gauss, il suffit de calculer le produit des coefficients diagonaux, en gardant à l'esprit que des lignes ont potentiellement été permutées. En notant $l$ le nombre de permutations de lignes effectuées pendant le pivot de Gauss, on a :
$$ det(A) = (-1)^l\prod_{i = 1}^na_{i,i}$$
En faisant de même pour les matrices $A_j$ (la valeur de $l$ est la même), on a :
$$ \forall j \in \llbracket1,n\rrbracket, det(A_j) = (-1)^l b_j \prod_{\substack{i=1 \\ i\neq j}}^na_{i,i}$$
\subsection{Algorithme général}
\subsubsection{Dernière version}
Cette version de l'algorithme utilise la borne d'Hadamard pour déterminer quand arrêter les calculs, et la règle de Cramer pour calculer la solution du système initial.
\newline
\begin{algorithm}[H]
	\DontPrintSemicolon
	\caption{Méthode modulaire de résolution des systèmes}
	\Entree{Un système de Cramer de taille $n$, à coefficients entiers}
	\Sortie{La solution $x$ du système}
	$prod \gets 1$
	\tcp*{Représente le produit des nombres premiers utilisés}
	$hada \gets$ Borne de Hadamard du système\\
	\Tq{$\frac{\sqrt{prod}}{2} < hada$}{
		Choisir $p$ premier\\
		Effectuer le pivot de Gauss dans $\mathbb{Z}/p\mathbb{Z}$\\
		En déduire le déterminant du système modulo $p$\\
		Ainsi que les déterminants du système avec chaque colonne remplacée par le second membre, toujours modulo $p$\\
		Utiliser les restes chinois pour obtenir tous ces déterminants modulo $prod \times p$\\
		$prod \gets prod \times p$
	}
	\tcp{Utilisation de la règle de Cramer pour obtenir la solution :}
	\Pour{k allant de 1 à n}{
		$x_k \gets \frac{\mbox{det}(A_k) \mbox{ mod } prod}{\mbox{det}(A) \mbox{ mod } prod}$
		\\
		\tcp{$A_k$ est la matrice des coefficients du système, avec $b$ à la place de la $k$-ième colonne, telle que définie dans la section \ref{subsec:cramer}}
	}
\end{algorithm}
\leavevmode \newline
\subsubsection{Anciennes versions}
\begin{algorithm}[H]
	\DontPrintSemicolon
	\caption{Ancienne variante, sans utiliser la règle de Cramer}
	\Entree{Un système de Cramer de taille $n$, à coefficients entiers}
	\Sortie{La solution $x$ du système}
	$prod \gets 1$
	\tcp*{Représente le produit des nombres premiers utilisés}
	$hada \gets$ Borne de Hadamard du système\\
	\Tq{$\frac{\sqrt{prod}}{2} < hada$}{
		Choisir $p$ premier\\
		Effectuer le pivot de Gauss dans $\mathbb{Z}/p\mathbb{Z}$\\
		En déduire une solution du système modulo $p$\\
		Utiliser les restes chinois pour obtenir une solution modulo $prod \times p$\\
		$prod \gets prod \times p$
	}
	$x \gets$ solution obtenue par reconstruction rationnelle
\end{algorithm}
\leavevmode \newline
[Dire quelque chose]
\newline \newline
\begin{algorithm}[H]
	\DontPrintSemicolon
	\caption{Première variante, n'utilise pas la règle de Cramer, ni la borne de Hadamard}
	\Entree{Un système de Cramer de taille $n$, à coefficients entiers}
	\Sortie{La solution $x$ du système}
	$prod \gets 1$
	\tcp*{Représente le produit des nombres premiers utilisés}
	\Tq{le nouveau candidat solution est différent de l'ancien}{
		Choisir $p$ premier\\
		Effectuer le pivot de Gauss dans $\mathbb{Z}/p\mathbb{Z}$\\
		En déduire une solution du système modulo $p$\\
		Utiliser les restes chinois pour obtenir une solution modulo $prod \times p$\\
		$prod \gets prod \times p$\\
		$x \gets$ candidat solution obtenu par reconstruction rationnelle
	}
\end{algorithm}
\leavevmode \newline
[Dire qu'utiliser la reconstruction rationnelle à chaque étape était bien trop couteux]
\subsection{Exemple}
Considérons le même exemple que d'habitude.
\begin{equation*}
	\begin{pmatrix}
		17 & 2 & -3 & & 9\\
		4 & 7 & -8 & & -5\\
		1 & 0 & 5 & & 4
	\end{pmatrix}
\end{equation*}
La borne de Hadamard de ce système est [...]
\newline
[Prendre en compte le 2nd membre dans son calcul ??]
\subsection{Complexité} \label{subsec:modcompl}
Le pivot de Gauss étant ici utilisé dans des corps finis, son coût est donc en $O(n^3)$ à chaque utilisation.
\newline
[Restes chinois]
\newline
[Reconstruction rationnelle -> $O(a^2 \mbox{ ln}(a)^2)$, trop coûteux]
\newline
[Nombre d'itérations/borne de Hadamard]
Pour atteindre la majoration du déterminant du système donnée par la borne de Hadamard, il est nécessaire d'effectuer $O(n \mbox{ ln}(n))$ exécutions du pivot de Gauss dans des $\mathbb{Z}/p\mathbb{Z}$.
[Dire qu'on effectue moins d'itérations avec la méthode de reconstruction/comparaison ?]
\newline
[Total]
\section{Outils utilisés} \label{sec:outils}
En plus du langage de programmation C et de ses librairies standard [parler des librairies standard ?], plusieurs outils ont été nécessaires pour mener à bien ce travail.
\subsection{La bibliothèque GMP}
GMP (GNU Multiple Precision) est une bibliothèque libre et open source qui permet de manipuler des nombres entiers, rationnels et flottants, avec une précision arbitraire (contrairement aux entiers et flottants disponibles nativement). On utilise ici uniquement les nombres entiers. GMP met à disposition des fonctions permettant d'effectuer diverses opérations sur les entiers, allant des calculs basiques aux recherches de PGCD et de coefficients de Bézout, en passant par des tests de primalité, de la génération de nombres pseudo-aléatoires, et des choses plus terre-à-terre comme l'affichage des nombres dans un fichier ou dans le terminal. La résolution de systèmes à coefficients entiers ayant tendance à faire apparaître des nombres d'assez grande taille, c'est avec cette bibliothèque que j'ai représenté la plupart des entiers dans ce travail.
\subsection{Représentation des nombres rationnels}
Les systèmes à coefficients entiers ayant des solutions rationnelles, il est nécessaire de trouver une façon de représenter les nombres rationnels. Plutôt que d'utiliser les rationnels fournis par GMP, j'ai choisi d'implémenter moi-même des nombres rationnels à partir des entiers de GMP, principalement car c'est une tâche assez simple qui permettait un premier contact avec la bibliothèque et sa documentation.
Un nombre rationnel est représenté par deux entiers : son numérateur et son dénominateur, supposés premiers entre eux. 
$$r = \frac{p}{q}, \mbox{ avec} \ p \in \mathbb{Z}\ \mbox{et} \ q \in \mathbb{N}^*$$
De cette façon, les nombres rationnels sont représentés de façon exacte (ça ne serait pas le cas en utilisant des flottants), et leurs numérateurs et dénominateurs peuvent être de taille arbitraire.
À la fin de chaque calcul, pour s'assurer que le numérateur et le dénominateur d'un rationnel restent premiers entre eux (ce qui évite de ralentir les calculs en traînant des entiers énormes inutilement), ils sont divisés par leur PGCD.
Il restait alors à écrire quelques fonctions pour manipuler ces rationnels : affectation, opérations de base, test d'égalité, initialisation/suppression... D'autres petites fonctions auraient raisonnablement pu être écrites, comme une comparaison entre deux rationnels, mais elles n'avaient pas vraiment d'utilité dans le cadre de ce travail.
Tout le code en lien avec cette implémentation se trouve dans les fichiers {\tt rationnels.c} et {\tt rationnels.h}.
\subsection{Représentation des systèmes linéaires} \label{subsec:systemes}
Lors de l'exécution du programme, les systèmes sont représentés par une matrice d'entiers de GMP, qui est elle-même représentée par un type structuré contenant le nombre de lignes {\tt n}, le nombre de colonnes {\tt m}, un tableau (1D) contenant tous les coefficients (y compris le second membre). Le nombre de colonnes a initialement été rajouté dans l'optique de permettre de résoudre un système pour plusieurs seconds membres à la fois, mais cette idée n'a finalement pas vu le jour, et donc en pratique {\tt m} = {\tt n+1}.
Pour accéder plus simplement aux coefficients du système, des fonctions {\tt lit\_coeff} et {\tt ecrit\_coeff} ont été écrites pour accéder aux coefficients du système à partir de leur numéro de ligne et de colonne.
D'autres fonctions ont été écrites pour afficher un système dans le terminal, vérifier si un vecteur est solution d'un système, ou encore pour initialiser, copier ou détruire la structure de système... Toutes ces fonctions sont dans les fichiers {\tt systemes.c} et {\tt systemes.h}.
\par Les systèmes sont lus depuis un fichier texte, ce qui permet à l'utilisateur de modifier et de consulter, relativement facilement, les systèmes que le programme va manipuler. Ces fichiers texte contiennent (sur une seule ligne, séparés par des espaces) {\tt n}, {\tt m}, puis tous les coefficients du système (ordonnés ligne par ligne, de gauche à droite et de haut en bas). Le code gérant la lecture des systèmes peut être consulté dans {\tt io.c}.
\subsection{Génération de systèmes aléatoires}
Pour pouvoir tester mes algorithmes sur des systèmes raisonnablement grands, il a été nécessaire d'implémenter un moyen de générer des systèmes aléatoires. Le tirage des coefficients a été simplement effectué à l'aide de la librairie GMP, qui permet de tirer uniformément des entiers dans $\llbracket0,2^b-1\rrbracket$ (où $b$ peut être arbitrairement grand). Les nombres ainsi obtenus sont ensuite changés de signe avec une probabilité $\frac{1}{2}$, pour obtenir des coefficients uniformément distribués dans $\llbracket-2^b,2^b-1\rrbracket$, s'écrivant donc avec $b+1$ bits. Les systèmes ainsi obtenus sont alors stockés dans des fichiers texte, et lus par le programme. Ceci a été implémenté dans {\tt io.c}.
\subsection{Représentation des éléments de $\mathbb{Z}/p\mathbb{Z}$}
Les nombres premiers p que l'on choisit pour les calculs dans $\mathbb{Z}/p\mathbb{Z}$ s'écrivent sur 30 bits (pas 31, pour éviter un dépassement d'entiers en faisant des sommes), donc les éléments de $\mathbb{Z}/p\mathbb{Z}$ peuvent être représentés par des entiers signés de 32 bits (c'est-à-dire des {\tt int}).
Les additions et soustractions sont effectuées en utilisant les opérations natives, puis en ajoutant ou enlevant $p$ de sorte à ce que le résultat soit dans $\llbracket0,p-1\rrbracket$.
Les multiplications sont effectuées de façon semblable, en multipliant d'abord les opérandes (il faut alors stocker ce résultat intermédiaire dans un {\tt long int} pour éviter un dépassement d'entiers) et en effectuant une division euclidienne par $p$.
L'inverse modulaire est calculé à l'aide de l'algorithme d'Euclide étendu.
\newline
En revanche, en général, pour $\mathbb{Z}/n\mathbb{Z}$ avec $n$ grand, on représente les éléments par des entiers de la librairie GMP.
\newline
[Parler de la représentation symétrique utilisée pour la "dernière" méthode modulaire (quand ça marchera)]
\section{Mesures du temps de calcul}
[Dire comment sont faites les mesures] [+ faire une sorte de tableau ?]
\section{Références}
\begin{itemize}
	\item Documentation de la bibliothèque GMP, par le projet GNU : \href{https://gmplib.org/manual/}{https://gmplib.org/manual}
	\item Le cours d'algèbre effective du second semestre de M1MG, par Samuel Le Fourn et Bernard Parisse [Lien ??]
	\item Page des algorithmes de Xcas, par Bernard Parisse : \href{https://www-fourier.univ-grenoble-alpes.fr/~parisse/giac/doc/fr/algo.html}{https://www-fourier.univ-grenoble-alpes.fr/~parisse/giac/doc/fr/algo.html}
	\item Mon code source pour ce travail : \href{https://github.com/Barni072/TER}{https://github.com/Barni072/TER}
\end{itemize}
\end{document}